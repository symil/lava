// Generated by `scripts/generate.js`

use utils::c_bindings::*;
use utils::vk_traits::*;
use utils::vk_ptr::*;
use utils::vk_convert::*;
use std::os::raw::c_char;
use std::ptr;
use std::mem;
use vulkan::vk::*;


/// Wrapper for [vkCreateInstance](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkCreateInstance.html).
pub fn vk_create_instance(create_info: VkInstanceCreateInfo) -> Result<VkInstance, (VkResult, VkInstance)> {
    unsafe {
        let raw_create_info = new_ptr_vk_value(&create_info);
        let mut vk_result = 0;
        let raw_instance = &mut mem::zeroed() as *mut RawVkInstance;
        
        vk_result = vkCreateInstance(raw_create_info, ptr::null(), raw_instance);
        
        let mut instance = new_vk_value(raw_instance);
        if vk_result == 0 {
            let fn_table = Box::into_raw(Box::new(VkFunctionTable::from_instance(*raw_instance)));
            VkSetup::vk_setup(&mut instance, fn_table);
        }
        free_vk_ptr(raw_create_info);
        if vk_result == 0 { Ok(instance) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), instance)) }
    }
}

/// Wrapper for [vkEnumerateInstanceExtensionProperties](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkEnumerateInstanceExtensionProperties.html).
pub fn vk_enumerate_instance_extension_properties(layer_name: Option<String>) -> Result<Vec<VkExtensionProperties>, (VkResult, Vec<VkExtensionProperties>)> {
    unsafe {
        let raw_layer_name = new_ptr_string_checked(&layer_name);
        let mut vk_result = 0;
        let mut raw_properties : *mut RawVkExtensionProperties = ptr::null_mut();
        let raw_property_count = &mut mem::zeroed() as *mut u32;
        vk_result = vkEnumerateInstanceExtensionProperties(raw_layer_name, raw_property_count, raw_properties);
        raw_properties = calloc(*raw_property_count as usize, mem::size_of::<RawVkExtensionProperties>()) as *mut RawVkExtensionProperties;
        
        vk_result = vkEnumerateInstanceExtensionProperties(raw_layer_name, raw_property_count, raw_properties);
        
        let properties = new_vk_array_checked(*raw_property_count, raw_properties).unwrap();
        free_ptr(raw_layer_name);
        free(raw_properties as *mut u8);
        if vk_result == 0 { Ok(properties) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), properties)) }
    }
}

/// Wrapper for [vkEnumerateInstanceLayerProperties](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkEnumerateInstanceLayerProperties.html).
pub fn vk_enumerate_instance_layer_properties() -> Result<Vec<VkLayerProperties>, (VkResult, Vec<VkLayerProperties>)> {
    unsafe {
        let mut vk_result = 0;
        let mut raw_properties : *mut RawVkLayerProperties = ptr::null_mut();
        let raw_property_count = &mut mem::zeroed() as *mut u32;
        vk_result = vkEnumerateInstanceLayerProperties(raw_property_count, raw_properties);
        raw_properties = calloc(*raw_property_count as usize, mem::size_of::<RawVkLayerProperties>()) as *mut RawVkLayerProperties;
        
        vk_result = vkEnumerateInstanceLayerProperties(raw_property_count, raw_properties);
        
        let properties = new_vk_array_checked(*raw_property_count, raw_properties).unwrap();
        free(raw_properties as *mut u8);
        if vk_result == 0 { Ok(properties) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), properties)) }
    }
}

/// Wrapper for [vkEnumerateInstanceVersion](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkEnumerateInstanceVersion.html).
pub fn vk_enumerate_instance_version() -> Result<VkVersion, (VkResult, VkVersion)> {
    unsafe {
        let mut vk_result = 0;
        let raw_api_version = &mut mem::zeroed() as *mut u32;
        
        vk_result = vkEnumerateInstanceVersion(raw_api_version);
        
        let api_version = new_vk_value(raw_api_version);
        if vk_result == 0 { Ok(api_version) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), api_version)) }
    }
}

extern {
    fn vkCreateInstance(create_info: *const RawVkInstanceCreateInfo, allocator: *const c_void, instance: *const RawVkInstance) -> RawVkResult;
    fn vkEnumerateInstanceExtensionProperties(layer_name: *const c_char, property_count: *const u32, properties: *const RawVkExtensionProperties) -> RawVkResult;
    fn vkEnumerateInstanceLayerProperties(property_count: *const u32, properties: *const RawVkLayerProperties) -> RawVkResult;
    fn vkEnumerateInstanceVersion(api_version: *const u32) -> RawVkResult;
}